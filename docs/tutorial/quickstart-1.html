<head>
    <title>DORF - QuickStart</title>
    <link rel="stylesheet" href="https://unpkg.com/bootstrap@4.0.0-alpha.6/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://unpkg.com/highlight.js@9.12.0/styles/agate.css">
    <script src="https://unpkg.com/highlight.js@9.12.0/lib/highlight.js"></script>
    <script src="https://unpkg.com/highlight.js@9.12.0/lib/languages/typescript.js"></script>
    <script>
        hljs.initHighlightingOnLoad();
    </script>
</head>

<div class="container">
    <h1 id="quickstart---part-i">QuickStart - part I</h1>
    <p>DORF (Domain Object Reactive Forms) is a library for Angular, which speeds up the creation of <em>Dynamic Forms</em>.</p>
    <h2 id="introduction">Introduction</h2>
    <p>First part of DORF QuickStart tutorial covers the following topics:</p>
    <ul>
        <li>what is the target form structure,<br /></li>
        <li>how to use CSS libraries together with DORF,<br /></li>
        <li>how to play with basic DORF annotations</li>
    </ul>
    <h3 id="prerequisites">Prerequisites</h3>
    <p>It may be useful to read the following tutorials on Angular:</p>
    <ul>
        <li><a href="https://angular.io/guide/reactive-forms">Reactive Forms</a><br /></li>
        <li><a href="https://angular.io/guide/dynamic-form">Dynamic Forms</a></li>
    </ul>
    <p>The latter from the list was a direct inspiration for DORF.</p>
    <h3 id="what-does-domain-object-mean">What does <em>Domain Object</em> mean?</h3>
    <p>Library has to have a catchy name and DORF sounds better than ORF (only Germans are allowed to disagree :)). The term
        is taken from the Domain Driven Design approach (DDD), where system is divided into separate parts (domains). It's
        not like every object in the system should have its own form. It is needed for the selected, <em>main</em> ones.
        And those can be called Domain Objects even if the architecture is not DDD.</p>
    <h2 id="step-by-step">Step-by-step</h2>
    <p>We are going to create a simple form, getting to know DORF better and better with each step.</p>
    <h3 id="starting-point">Starting point</h3>
    <p>In order to start we should generate/download an app according to <a href="https://angular.io/guide/quickstart">Angular QuickStart</a>.<br
        />Then it is needed to install DORF, e.g. by using <code>npm install dorf --save</code> command.</p>
    <h3 id="css-library">CSS library</h3>
    <p>DORF is very configurable. Especially when it comes to the CSS classes. From the beginning, the main idea was to leave
        a choose of CSS framework to the end library user.</p>
    <p>For the tutorial let's choose <a href="http://v4-alpha.getbootstrap.com/">Bootstrap</a>, while the library's GitHub examples
        use rather <a href="https://purecss.io/">Pure</a>. It is enough to include just CSS part from the library, so the
        changed
        <code>index.html</code> can look like this:</p>
    <pre class="sourceCode html"><code class="sourceCode html"><span class="er">&lt;</span>!doctype html&gt;
<span class="kw">&lt;html&gt;</span>

<span class="kw">&lt;head&gt;</span>
  <span class="kw">&lt;meta</span><span class="ot"> charset=</span><span class="st">&quot;utf-8&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;title&gt;</span>DORF App<span class="kw">&lt;/title&gt;</span>
  <span class="kw">&lt;base</span><span class="ot"> href=</span><span class="st">&quot;/&quot;</span><span class="kw">&gt;</span>

  <span class="kw">&lt;meta</span><span class="ot"> name=</span><span class="st">&quot;viewport&quot;</span><span class="ot"> content=</span><span class="st">&quot;width=device-width, initial-scale=1&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;link</span><span class="ot"> rel=</span><span class="st">&quot;icon&quot;</span><span class="ot"> type=</span><span class="st">&quot;image/x-icon&quot;</span><span class="ot"> href=</span><span class="st">&quot;favicon.ico&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;link</span><span class="ot"> rel=</span><span class="st">&quot;stylesheet&quot;</span><span class="ot"> href=</span><span class="st">&quot;https://unpkg.com/bootstrap@4.0.0-alpha.6/dist/css/bootstrap.min.css&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;/head&gt;</span>

<span class="kw">&lt;body&gt;</span>
  <span class="kw">&lt;app-root&gt;</span>Loading...<span class="kw">&lt;/app-root&gt;</span>
<span class="kw">&lt;/body&gt;</span>

<span class="kw">&lt;/html&gt;</span></code></pre>
    <h3 id="dorf-output">DORF output</h3>
    <p>To understand how to configure CSS in DORF, let's take a look at the skeleton of the form generated by the library:</p>
    <pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;dorf-form-component&gt;</span>                                    
  <span class="kw">&lt;form</span><span class="ot"> class=</span><span class="st">&quot;form&quot;</span><span class="kw">&gt;</span>                                    
    <span class="kw">&lt;fieldset</span><span class="ot"> class=</span><span class="st">&quot;fieldset&quot;</span><span class="kw">&gt;</span><span class="co">&lt;!-- optional --&gt;</span>         
      <span class="kw">&lt;section</span><span class="ot"> class=</span><span class="st">&quot;section&quot;</span><span class="kw">&gt;</span>                          
        <span class="kw">&lt;dorf-field-wrapper</span><span class="ot"> class=</span><span class="st">&quot;wrapper&quot;</span><span class="kw">&gt;</span><span class="co">&lt;!--...--&gt;</span><span class="kw">&lt;/dorf-field-wrapper&gt;</span>
        <span class="kw">&lt;dorf-field-wrapper</span><span class="ot"> class=</span><span class="st">&quot;wrapper&quot;</span><span class="kw">&gt;</span><span class="co">&lt;!--...--&gt;</span><span class="kw">&lt;/dorf-field-wrapper&gt;</span>
        <span class="co">&lt;!-- ... --&gt;</span>
      <span class="kw">&lt;/section&gt;</span>
      <span class="kw">&lt;dorf-group-wrapper&gt;</span><span class="co">&lt;!--...--&gt;</span><span class="kw">&lt;/dorf-group-wrapper&gt;</span>
      <span class="kw">&lt;dorf-group-wrapper&gt;</span><span class="co">&lt;!--...--&gt;</span><span class="kw">&lt;/dorf-group-wrapper&gt;</span>
      <span class="kw">&lt;section</span><span class="ot"> class=</span><span class="st">&quot;section&quot;</span><span class="kw">&gt;</span>
        <span class="co">&lt;!--...--&gt;</span>
      <span class="kw">&lt;/section&gt;</span>
      <span class="co">&lt;!-- ... --&gt;</span>
    <span class="kw">&lt;/fieldset&gt;</span>
    <span class="kw">&lt;dorf-buttons&gt;</span><span class="co">&lt;!--...--&gt;</span><span class="kw">&lt;/dorf-buttons&gt;</span>
  <span class="kw">&lt;/form&gt;</span>
<span class="kw">&lt;/dorf-form-component&gt;</span></code></pre>
    <p>In general:</p>
    <ol>
        <li><code>dorf-form-component</code> - Angular component created by the library consumer to manage the form<br /></li>
        <li><code>form</code> - standard HTML element; first place where classes can be set during importing DORF module (<code>form</code>            property)<br /></li>
        <li><code>fieldset</code> - optional parameter. Visible when <code>renderFieldsetAroundFields</code> set to <code>true</code>            inside <code>@DorfForm</code> annotation. CSS classes for this can be set when importing DORF module (<code>fieldset</code>            property). This main <code>fieldset</code> doesn't contain any <code>legend</code> (unlike the <code>fieldset</code>            from <code>dorf-group-wrapper</code>)<br /></li>
        <li><code>section</code> - HTML element; it is always around <code>dorf-field-wrapper</code> elements. When importing
            DORF module, there is a <code>columnsNumber</code> property which defines how many <code>dorf-field-wrapper</code>            elements should be inside each <code>section</code>. Section CSS classes can by set when importing DORF module
            (
            <code>section</code> property)<br /></li>
        <li><code>dorf-field-wrapper</code> - DORF component which &quot;wraps&quot; the field context. It stores label, field
            and the error message. It is described in detail later. CSS classes for this component can be assigned at many
            levels, but always with a <code>wrapper</code> property<br /></li>
        <li><code>dorf-group-wrapper</code> - another DORF component, used when nesting DORF Objects. We are not going to use
            this in this tutorial and CSS classes cannot be assigned directly at its level anyway<br /></li>
        <li><code>dorf-buttons</code> - DORF component for storing form buttons. When importing DORF module, there is <code>renderWithoutButtons</code>            property and when it is set to true, <code>dorf-buttons</code> won't be presented. CSS classes cannot be set
            directly on the component, but later, within its body</li>
    </ol>
    <h4 id="the-output-of-dorf-field-wrapper">The output of <code>dorf-field-wrapper</code></h4>
    <p>The content of <code>dorf-field-wrapper</code> looks like this:</p>
    <pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;dorf-field-wrapper</span><span class="ot"> class=</span><span class="st">&quot;wrapper&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;label</span><span class="ot"> class=</span><span class="st">&quot;label&quot;</span><span class="kw">&gt;</span>...<span class="kw">&lt;/label&gt;</span>
  <span class="kw">&lt;dorf-field</span><span class="ot"> class=</span><span class="st">&quot;fieldGeneralization&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;dorf-input</span><span class="ot"> class=</span><span class="st">&quot;dorfField&quot;</span><span class="kw">&gt;</span><span class="co">&lt;!--...--&gt;</span><span class="kw">&lt;/dorf-input&gt;</span>
    <span class="kw">&lt;dorf-radio</span><span class="ot"> class=</span><span class="st">&quot;dorfField&quot;</span><span class="kw">&gt;</span><span class="co">&lt;!--...--&gt;</span><span class="kw">&lt;/dorf-radio&gt;</span>
    <span class="kw">&lt;dorf-select</span><span class="ot"> class=</span><span class="st">&quot;dorfField&quot;</span><span class="kw">&gt;</span><span class="co">&lt;!--...--&gt;</span><span class="kw">&lt;/dorf-select&gt;</span>
    <span class="kw">&lt;dorf-checkbox</span><span class="ot"> class=</span><span class="st">&quot;dorfField&quot;</span><span class="kw">&gt;</span><span class="co">&lt;!--...--&gt;</span><span class="kw">&lt;/dorf-checkbox&gt;</span>
    <span class="co">&lt;!--...--&gt;</span>
  <span class="kw">&lt;/dorf-field&gt;</span>
  <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;error&quot;</span><span class="kw">&gt;</span>...<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/dorf-field-wrapper&gt;</span></code></pre>
    <p>In short words:</p>
    <ol>
        <li><code>label</code> and error are within standard HTML elements. CSS classes for them can be set thanks to <code>label</code>            and <code>error</code> properties<br /></li>
        <li><code>dorf-field</code> is a DORF component which allows operating on fields without going into detail. It stores
            both out of the box fields and the custom ones, added with <code>dorfFields</code> property when importing DORF
            module. At the end only one of the fields listed within <code>dorf-field</code> body is presented. Therefore
            the good way of thinking about this component is &quot;field generalization&quot;. Therefore CSS classes can
            be assigned to this, with a <code>fieldGeneralization</code> property<br /></li>
        <li><code>dorf-input</code>, <code>dorf-radio</code>, <code>dorf-select</code>, <code>dorf-checkbox</code> - out of the
            box DORF components. Each one represents a different HTML field. As mentioned above, only one of them would be
            presented under the <code>dorf-field</code> under the concrete conditions. It is possible to assign CSS classes
            at this level with
            <code>dorfField</code> property</li>
    </ol>
    <p>DORF is written in a very modular way, that's why each field is defined by its own component.</p>
    <h4 id="the-output-of-different-out-of-the-box-fields">The output of different out of the box fields</h4>
    <p>We can divide out of the box fields into 2 groups: those which supprot additional labeling and those which don't. Knowing
        HTML, you can guess that <code>dorf-checkbox</code> and <code>dorf-radio</code> are supproting additional labelling
        (inner label).
    </p>
    <p>Inner label means here that we have a label around the field. Let's take a look at the simplified content of <code>dorf-radio</code>:</p>
    <pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;label</span> <span class="er">*ngFor</span><span class="ot"> class=</span><span class="st">&quot;innerLabel&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;radio&quot;</span><span class="ot"> class=</span><span class="st">&quot;htmlField&quot;</span><span class="kw">&gt;</span> ...
<span class="kw">&lt;/label&gt;</span></code></pre>
    <p>Each option is wrapped with the label. Label can have CSS classes, defined by an <code>innerLabel</code> property. Options
        are standard HTML <code>input</code> elements which can have CSS classes assigned with <code>htmlField</code> property.
        Worth mentioning that <code>innerLabel</code> is independent from <code>label</code> underneath <code>dorf-field-wrapper</code>,
        so it is possible to have 2 labels, to have just a chosen one or to not have any at all.</p>
    <p>On the other hand, <code>dorf-select</code> and <code>dorf-input</code> don't supprot inner labels. Simplified template
        of
        <code>dorf-input</code> looks like this:</p>
    <pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> class=</span><span class="st">&quot;htmlField&quot;</span> <span class="kw">/&gt;</span></code></pre>
    <p>Nothing fancy :) once again, <code>htmlField</code> property is strictly connected with the HTML representation of the
        form field.
    </p>
    <h4 id="the-output-of-dorf-buttons">The output of <code>dorf-buttons</code></h4>
    <p>The last DORF component is pretty simple when it comes to its body:</p>
    <pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;section</span><span class="ot"> class=</span><span class="st">&quot;group&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> class=</span><span class="st">&quot;save&quot;</span><span class="kw">&gt;</span>Save<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> class=</span><span class="st">&quot;reset&quot;</span><span class="kw">&gt;</span>Reset<span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/section&gt;</span></code></pre>
    <p>There are 2 predefined buttons, grouped within the <code>section</code> HTML element. CSS classes can be assigned to
        them thanks to <code>group</code>, <code>save</code> and <code>reset</code> properties.</p>
    <h3 id="example-requirements">Example requirements</h3>
    <p>Understanding the above dependencies helps importing DORF in a way it matches our needs. Let's keep things simple and
        define the following requirements:</p>
    <ol>
        <li>Form for the user (login, password, acceptance of terms and conditions)<br /></li>
        <li>1 field per line<br /></li>
        <li>Label and field in the same line as <a href="https://v4-alpha.getbootstrap.com/components/forms/#textual-inputs">here</a><br
            /></li>
        <li>Checkbox with just one label as <a href="https://v4-alpha.getbootstrap.com/components/forms/#disabled-states">here</a><br
            /></li>
        <li>1 button for submitting the form</li>
    </ol>
    <h3 id="initial-configuration">Initial configuration</h3>
    <p>From the requirements we can figure out that just <code>input</code> and <code>checkbox</code> fields should be used.
        When configuring CSS classes, it is good to have as much as possible at the general level and override just a couple
        of styles at the field level. Then, in rare cases, everything can be overriden at the definition level. DORF approach
        to CSS is similar to the well-known browser one - the closer the element, the more likely to be assigned.</p>
    <p>At the end <code>app.module</code> can look like this:</p>
    <pre class="typescript"><code>import { BrowserModule } from &#39;@angular/platform-browser&#39;;
import { NgModule } from &#39;@angular/core&#39;;
import { FormsModule } from &#39;@angular/forms&#39;;
import { HttpModule } from &#39;@angular/http&#39;;

import { DorfModule, DorfField } from &#39;dorf&#39;;

import { AppComponent } from &#39;./app.component&#39;;

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    DorfModule.forRoot({
      css: {
        section: &#39;row&#39;,
        wrapper: &#39;form-group col-12 row&#39;,
        label: &#39;col-2 col-form-label&#39;,
        fieldGeneralization: &#39;col-10&#39;,
        htmlField: &#39;form-control&#39;
      },
      dorfFields: [{
        tag: DorfField.CHECKBOX,
        css: {
          wrapper: &#39;checkbox col-12 row&#39;,
          htmlField: &#39;checkbox&#39;
        }
      }]
    })
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }</code></pre>
    <p>Importing <code>DorfModule</code> is needed in order to use it under the <code>imports</code> module property. Then,
        the configuration is done by executing <code>forRoot</code> static method on the module level and passing <code>IDorfService</code>        object as a parameter. Many things are defined at the general, <code>css</code> level. CSS classes are taken from
        the Bootstrap examples and mapped according to the knowledge about the rendering:</p>
    <ul>
        <li>each <code>section</code> should be a separate block element (<code>'row'</code>),<br /></li>
        <li>something, which groups field and label (<code>wrapper</code>) should be both <code>'form-group'</code> and <code>'row'</code>;
            it is already under the <code>'row'</code>, so we should add <code>'col-12'</code> at this level as well,<br
            /></li>
        <li>in order to have <code>label</code> and field in the same line, <code>'col-'</code> classes should be assigned (to
            <code>label</code> and to <code>fieldGeneralization</code>),<br /></li>
        <li><code>htmlField</code> got <code>'form-control'</code> class</li>
    </ul>
    <p>The only exception from those patterns is <code>dorf-checkbox</code>. In order to assign CSS classes just to this kind
        of field (and override the previous classes if exist), <code>dorfFields</code> array is used. It can change existing
        fields and/or add new ones. <code>tag</code> property is the required key for elements in this array (in our case
        key was taken from imported <code>DorfField</code> class).</p>
    <h3 id="model-for-the-form">Model for the form</h3>
    <p>For the simple requirements we have here, there is a simple model to be created. It's a good idea to start with a &quot;contract&quot;.
        Let's create a file <code>src/app/user/model.ts</code> with a following interface inside:</p>
    <pre class="typescript"><code>export interface IUser {
  _login: string;
  _password: string;
  _acceptance: boolean;
}</code></pre>
    <p>Interface will be the thing returned from our form. Interface properties have to match the future annotated Domain Object
        class properties. Let's create a class now and enrich it with a constructor, consuming the interface. Let's act as
        guys who care about the security (the usage of <code>btoa</code> and stuff):</p>
    <pre class="typescript"><code>export class User {
  private _login: string;
  private _password: string;
  private _acceptance: boolean;

  constructor(options?: IUser) {
    if (options) {
      this._login = options._login;
      this._password = options._password;
      this._acceptance = options._acceptance;
    }
  }

  update(options?: IUser) {
    if (options) {
      this._login = options._login;
      this._password = options._password;
      this._acceptance = options._acceptance;
    }
  }

  get login() { return this._login; }
  get password() { return btoa(this._password); }
  get acceptance() { return this._acceptance; }

  get basicAuth() {
    if (this._login &amp;&amp; this._password) {
      return btoa(`${this._login}:${this._password}`);
    }
  }
}</code></pre>
    <p>Model is almost ready. The last part is to make it DORF! The final shape of <code>model.ts</code> can look like this:</p>
    <pre class="typescript"><code>import { Validators } from &#39;@angular/forms&#39;;
import { DorfObject, InputType, DorfInput, DorfCheckbox } from &#39;dorf&#39;;

export interface IUser {
  _login: string;
  _password: string;
  _acceptance: boolean;
}

@DorfObject()
export class User {
  @DorfInput({
    label: &#39;Username&#39;,
    type: &#39;input&#39; as InputType,
    validator: Validators.required
  })
  private _login: string;

  @DorfInput({
    label: &#39;Password&#39;,
    type: &#39;password&#39; as InputType,
    validator: Validators.required
  })
  private _password: string;

  @DorfCheckbox({
    innerLabel: &#39;I accept the terms and conditions&#39;,
    validator: Validators.requiredTrue
  })
  private _acceptance: boolean;

  constructor(options?: IUser) {
    if (options) {
      this._login = options._login;
      this._password = options._password;
      this._acceptance = options._acceptance;
    }
  }

  update(options?: IUser) {
    if (options) {
      this._login = options._login;
      this._password = options._password;
      this._acceptance = options._acceptance;
    }
  }

  get login() { return this._login; }
  get password() { return btoa(this._password); }
  get acceptance() { return this._acceptance; }

  get basicAuth() {
    if (this._login &amp;&amp; this._password) {
      return btoa(`${this._login}:${this._password}`);
    }
  }
}</code></pre>
    <p>It is OK to put DORF annotations on the private fields. It is a property name which matters here, not an access modifier.
        And the above piece of code, should proove that DORF is about <em>Model-driven forms within the model</em>.</p>
    <h3 id="form-component">Form component</h3>
    <p>To finalize the app, we need just one more piece from the Angular library - component which consumes <code>DorfObject</code>.
        Here is the example code of <code>user-form.component.ts</code> from <code>src/app/user/</code> directory:</p>
    <pre class="typescript"><code>import { Component, Output, EventEmitter } from &#39;@angular/core&#39;;
import { IDorfForm, DorfForm, DorfObjectInput, DorfConfigService } from &#39;dorf&#39;;

import { IUser, User } from &#39;./model&#39;;

@DorfForm()
@Component({
  selector: &#39;app-user-form&#39;
})
export class UserFormComponent implements IDorfForm {
  @DorfObjectInput() user: User;

  constructor(public config: DorfConfigService) { }

  onDorfSubmit() {
    this.user.update(this[&#39;form&#39;].value as IUser);
  }
}
</code></pre>
    <p>A couple of things worth mentioning:</p>
    <ol>
        <li><code>DorfForm</code> is a special annotation, which should be placed over <code>Component</code> annotation; if
            <code>Component</code> has no <code>template</code> nor <code>templateUrl</code>, then <code>DorfForm</code>            generates the template for us!
            <code>DorfForm</code> can consume an interface with 3 options: <code>additionalTags</code>, <code>renderFieldsetAroundFields</code>            and <code>renderWithoutButtons</code><br /></li>
        <li><code>IDorfForm</code> is a helper interface, something like e.g. <code>OnChange</code> from Angular which forces
            us to have <code>DorfConfigService</code> somewhere inside the component<br /></li>
        <li><code>DorfObjectInput</code> works like Angular <code>Input</code>, but should be used once within the component
            in order to point out an object marked as <code>DorfObject</code> previously<br /></li>
        <li><code>DorfConfigService</code> is needed within the component; it should be injected and used in the constructor
            e.g. to disable all the fields<br /></li>
        <li><code>onDorfSubmit</code> is a special method, connected with DORF save button from <code>dorf-buttons</code>; <code>this['form'].value</code>            is the way of getting an object with actual form values (which can be casted to <code>IUser</code> in our case)</li>
    </ol>
    <p><code>UserFormComponent</code> has to be presented inside the main module <code>declarations</code> array.</p>
    <h3 id="polishing-the-app">Polishing the app</h3>
    <p>At the end of the first iteration, we should update <code>AppComponent</code>:</p>
    <pre class="typescript"><code>import { Component } from &#39;@angular/core&#39;;

import { User } from &#39;./user/model&#39;;

@Component({
  selector: &#39;app-root&#39;,
  templateUrl: &#39;./app.component.html&#39;,
  styleUrls: [&#39;./app.component.css&#39;]
})
export class AppComponent {
  title = &#39;My DORF App&#39;;

  // object to be passed to the form
  user: User = new User();
}</code></pre>
    <p>And its HTML:</p>
    <pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1&gt;</span>
  {{title}}
<span class="kw">&lt;/h1&gt;</span>

<span class="kw">&lt;app-user-form</span> <span class="er">[user]</span><span class="ot">=</span><span class="st">&quot;user&quot;</span><span class="kw">&gt;&lt;/app-user-form&gt;</span>

<span class="co">&lt;!-- the evidence that the user has changed --&gt;</span>
<span class="kw">&lt;hr&gt;</span> Basic {{user.basicAuth}}</code></pre>
    <h3 id="recap">Recap</h3>
    <p>First version is ready. It can be run with <code>npm start</code> command and verified on <em>localhost:4200</em>. Things
        to be improved in the second part of the tutorial:</p>
    <ol>
        <li>There are no indicators on the required fields; in our case all the fields are required, but anyway...<br /></li>
        <li>There are 2 buttons visible and just the first one is doing something<br /></li>
        <li>First button is <code>'Save'</code> instead of <code>'Submit'</code><br /></li>
        <li><code>update</code> function is not the perfect way of acting with Dorf Object</li>
    </ol>
    <h2 id="the-future">The future</h2>
    <p>DORF is still under the development, but its code already allows for handling plenty of use cases and scenarios, which
        are not yet presented in tutorials.</p>
    <h3 id="planned-tutorials">Planned tutorials</h3>
    <ul>
        <li>DORF QuickStart - part II<br /></li>
        <li>Advanced options and overriding DORF components<br /></li>
        <li>Nested objects and a column layout<br /></li>
        <li>Adding custom fields<br /></li>
        <li>Testing DORF</li>
    </ul>
</div>